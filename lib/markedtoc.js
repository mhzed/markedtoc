// Generated by CoffeeScript 1.7.1
(function() {
  var marked, newLexer, oldLexer, replaceToc;

  marked = require('marked');

  oldLexer = marked.lexer;

  newLexer = function(data, options) {
    var toks;
    toks = oldLexer(data, options);
    return replaceToc(toks);
  };

  marked.Lexer.lex = newLexer;

  marked.lexer = newLexer;


  /*
    tokens: returned by marked.Lexer.lex()
    returns:  tokens with TOC filled in
   */

  replaceToc = function(tokens) {
    var addSection, currentLevel, currentStack, i, iToc, k, makeToc, nextStack, root, rootLevel, testTOC, tocParam, tocTokens, tok, token, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3;
    testTOC = function(token) {
      var m;
      if (token.type === "paragraph") {
        m = /^\[toc(.*)\]$/i.exec(token.text);
        if (m) {
          return m[1];
        } else {
          return void 0;
        }
      } else {
        return void 0;
      }
    };
    iToc = void 0;
    addSection = true;
    for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
      tok = tokens[i];
      tocParam = testTOC(tok);
      if (tocParam !== void 0) {
        iToc = i;
        addSection = tocParam === ".";
        break;
      }
    }
    if (iToc === void 0) {
      return tokens;
    }
    tocTokens = [];
    root = [];
    rootLevel = 0;
    currentStack = root;
    currentLevel = rootLevel;
    for (i = _j = _ref = iToc + 1, _ref1 = tokens.length; _ref <= _ref1 ? _j < _ref1 : _j > _ref1; i = _ref <= _ref1 ? ++_j : --_j) {
      token = tokens[i];
      if (token.type === "heading") {
        if (token.depth > currentLevel) {
          for (k = _k = rootLevel, _ref2 = token.depth - currentLevel; rootLevel <= _ref2 ? _k < _ref2 : _k > _ref2; k = rootLevel <= _ref2 ? ++_k : --_k) {
            nextStack = [];
            currentStack.push(nextStack);
            currentStack = nextStack;
          }
          currentLevel = token.depth;
        } else if (currentLevel > token.depth) {
          currentStack = root;
          for (k = _l = rootLevel, _ref3 = token.depth; rootLevel <= _ref3 ? _l < _ref3 : _l > _ref3; k = rootLevel <= _ref3 ? ++_l : --_l) {
            currentStack = currentStack[currentStack.length - 1];
          }
          currentLevel = token.depth;
        }
        currentStack.push(token);
      }
    }
    while (root.length === 1) {
      root = root[0];
    }
    makeToc = function(stack, toc, levelStacks) {
      var headingId, item, label, tocId, x, y;
      toc.push({
        type: 'list_start',
        ordered: false,
        isToc: true
      });
      x = 0;
      while (x < stack.length) {
        item = stack[x];
        if (item instanceof Array) {
          makeToc(item, toc, levelStacks.concat(1));
        } else {
          tocId = levelStacks.join(".");
          label = item.text;
          if (addSection) {
            label = tocId + " " + label;
          }
          item.text = label;
          headingId = label.toLowerCase().replace(/[^\w]+/g, '-');
          toc.push({
            type: 'list_item_start'
          });
          toc.push({
            type: 'text',
            text: "[" + label + "](#" + headingId + ")"
          });
          y = x + 1;
          while (y < stack.length && stack[y] instanceof Array) {
            makeToc(stack[y], toc, levelStacks.concat(1));
            x++;
            y++;
          }
          toc.push({
            type: 'list_item_end'
          });
          levelStacks[levelStacks.length - 1]++;
          x++;
        }
      }
      return toc.push({
        type: 'list_end'
      });
    };
    makeToc(root, tocTokens, [1]);
    tokens.splice.apply(tokens, [iToc, 1].concat(tocTokens));
    return tokens;
  };

  module.exports = marked;

}).call(this);

//# sourceMappingURL=markedtoc.map
