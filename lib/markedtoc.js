// Generated by CoffeeScript 1.7.1
(function() {
  var findToc, marked, replaceToc;

  marked = require('marked');

  module.exports = marked;

  (function() {
    var newLexer, oldLexer;
    oldLexer = marked.lexer;
    newLexer = function(data, options) {
      var toks;
      toks = oldLexer(data, options);
      return replaceToc(toks);
    };
    marked.Lexer.lex = newLexer;
    return marked.lexer = newLexer;
  })();

  (function() {
    var renderer;
    renderer = new marked.Renderer();
    renderer.list = function(body, ordered) {
      var type;
      if (ordered === 'toc') {
        return "<ul id='toc'>" + body + "</ul>";
      } else {
        type = ordered ? 'ol' : 'ul';
        return '<' + type + '>\n' + body + '</' + type + '>\n';
      }
    };
    return marked.setOptions({
      renderer: renderer
    });
  })();


  /*
    tokens: returned by marked.Lexer.lex()
    returns:  iToc -> index of [TOC] paragraph, undefined if not found
              addSection -> [TOC.] detected, prefix heading with numeric section numbers
   */

  findToc = function(tokens) {
    var addSection, i, iToc, testTOC, tocParam, tok, _i, _len;
    testTOC = function(token) {
      var m;
      if (token.type === "paragraph") {
        m = /^\[toc(.*)\]$/i.exec(token.text);
        if (m) {
          return m[1];
        } else {
          return void 0;
        }
      } else {
        return void 0;
      }
    };
    iToc = void 0;
    addSection = true;
    for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
      tok = tokens[i];
      tocParam = testTOC(tok);
      if (tocParam !== void 0) {
        iToc = i;
        addSection = tocParam === ".";
        break;
      }
    }
    return [iToc, addSection];
  };


  /*
  tokens: returned by marked.Lexer.lex()
  returns:  tokens with [TOC] paragraph replaced and filled in with toc lists
   */

  replaceToc = function(tokens) {
    var addSection, currentLevel, currentStack, i, iToc, k, makeToc, nextStack, root, rootLevel, tocTokens, token, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4;
    _ref = findToc(tokens), iToc = _ref[0], addSection = _ref[1];
    if (iToc === void 0) {
      return tokens;
    }
    tocTokens = [];
    root = [];
    rootLevel = 0;
    currentStack = root;
    currentLevel = rootLevel;
    for (i = _i = _ref1 = iToc + 1, _ref2 = tokens.length; _ref1 <= _ref2 ? _i < _ref2 : _i > _ref2; i = _ref1 <= _ref2 ? ++_i : --_i) {
      token = tokens[i];
      if (token.type === "heading") {
        if (token.depth > currentLevel) {
          for (k = _j = rootLevel, _ref3 = token.depth - currentLevel; rootLevel <= _ref3 ? _j < _ref3 : _j > _ref3; k = rootLevel <= _ref3 ? ++_j : --_j) {
            nextStack = [];
            currentStack.push(nextStack);
            currentStack = nextStack;
          }
          currentLevel = token.depth;
        } else if (currentLevel > token.depth) {
          currentStack = root;
          for (k = _k = rootLevel, _ref4 = token.depth; rootLevel <= _ref4 ? _k < _ref4 : _k > _ref4; k = rootLevel <= _ref4 ? ++_k : --_k) {
            currentStack = currentStack[currentStack.length - 1];
          }
          currentLevel = token.depth;
        }
        currentStack.push(token);
      }
    }
    while (root.length === 1) {
      root = root[0];
    }
    makeToc = function(stack, toc, levelStacks) {
      var headingId, item, label, tocId, x, y;
      toc.push({
        type: 'list_start',
        ordered: 'toc'
      });
      x = 0;
      while (x < stack.length) {
        item = stack[x];
        if (item instanceof Array) {
          makeToc(item, toc, levelStacks.concat(1));
        } else {
          tocId = levelStacks.join(".");
          label = item.text;
          if (addSection) {
            label = tocId + " " + label;
          }
          item.text = label;
          headingId = label.toLowerCase().replace(/[^\w]+/g, '-');
          toc.push({
            type: 'list_item_start'
          });
          toc.push({
            type: 'text',
            text: "[" + label + "](#" + headingId + ")"
          });
          y = x + 1;
          while (y < stack.length && stack[y] instanceof Array) {
            makeToc(stack[y], toc, levelStacks.concat(1));
            x++;
            y++;
          }
          toc.push({
            type: 'list_item_end'
          });
          levelStacks[levelStacks.length - 1]++;
          x++;
        }
      }
      return toc.push({
        type: 'list_end'
      });
    };
    makeToc(root, tocTokens, [1]);
    tokens.splice.apply(tokens, [iToc, 1].concat(tocTokens));
    return tokens;
  };

}).call(this);

//# sourceMappingURL=markedtoc.map
