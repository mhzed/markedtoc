// Generated by CoffeeScript 1.8.0
(function() {
  var XmlspecRenderer, escapeXml, marked,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  marked = require('./../lib/marked');

  escapeXml = function(xml, encode) {
    var rex;
    rex = !encode ? /&(?!#?\w+;)/g : /&/g;
    return xml.replace(rex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  };

  XmlspecRenderer = (function(_super) {
    __extends(XmlspecRenderer, _super);

    function XmlspecRenderer(options) {
      this.sectionStack = [];
      XmlspecRenderer.__super__.constructor.call(this, options);
      this.options.xhtml = true;
      this.list_ordered = [];
    }

    XmlspecRenderer.prototype.enterToken = function(token) {
      switch (token.type) {
        case 'list_start':
          return this.list_ordered.push(token.ordered);
        case 'list_end':
          return this.list_ordered.pop();
      }
    };

    XmlspecRenderer.prototype.code = function(code, lang, escaped) {
      if (lang === "inline-md") {
        return "<eg>\n" + (marked.inlineLexer(code, '.')) + "\n</eg>";
      } else {
        return "<eg>\n" + (escaped ? code : escapeXml(code)) + "\n</eg>";
      }
    };

    XmlspecRenderer.prototype.heading = function(text, level, raw) {
      var id, ret;
      id = raw.toLowerCase().replace(/[^\w]+/g, '-');
      ret = "";
      if (this.sectionStack.length === 0) {
        ret += this._nextHeading(0, "_spec", "_spec");
      }
      if (level === 1 && this.sectionStack.length === 1) {
        return ret;
      } else {
        if (level >= 2 && this.sectionStack.length === 1) {
          ret += this._nextHeading(1, "body", "body");
        }
        ret += this._nextHeading(level, text, id);
        return ret;
      }
    };

    XmlspecRenderer.prototype._nextHeading = function(level, text, id) {
      var lastId, lastLevel, lastid, lastlevel, ret, secs, _html, _i, _len, _level, _ref, _ref1, _sec;
      ret = "";
      if (this.sectionStack.length > 0) {
        secs = (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.sectionStack.slice(0).reverse();
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], lastLevel = _ref1[0], lastId = _ref1[1];
            if (lastLevel >= level) {
              _results.push([lastLevel, lastId]);
            }
          }
          return _results;
        }).call(this);
        if (secs.length > 0) {
          ret = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = secs.length; _i < _len; _i++) {
              _level = secs[_i][0];
              if (_level > 1) {
                _results.push("</div" + (_level - 1) + ">\n");
              }
            }
            return _results;
          })()).join("");
          _ref = (function() {
            var _j, _len, _results;
            _results = [];
            for (_j = 0, _len = secs.length; _j < _len; _j++) {
              _sec = secs[_j];
              if (_level <= 1) {
                _results.push(_sec);
              }
            }
            return _results;
          })();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], lastlevel = _ref1[0], lastid = _ref1[1];
            if (lastlevel === 1) {
              if (lastid === "back") {
                ret += "</back>";
              } else {
                ret += "</body>";
              }
            } else if (lastlevel === 0) {
              ret += "</spec>";
            }
          }
          this.sectionStack = this.sectionStack.slice(0, -secs.length);
        }
      }
      this.sectionStack.push([level, id]);
      _html = (function(_this) {
        return function() {
          if (level < 0) {
            return "";
          } else if (level === 0) {
            return "<spec>";
          } else if (level === 1) {
            if (/^\s*back\s*$/i.test(text)) {
              return "<back>";
            } else {
              return "<body>";
            }
          } else {
            return "<div" + (level - 1) + " id='" + id + "'>\n<head>" + text + "</head>\n";
          }
        };
      })(this)();
      return ret + _html;
    };

    XmlspecRenderer.prototype.closeDoc = function() {
      return this._nextHeading(-1, "", "");
    };

    XmlspecRenderer.prototype.list = function(body, ordered) {
      if (ordered) {
        return "<olist>" + body + "</olist>\n";
      } else {
        return "<ulist>" + body + "</ulist>\n";
      }
    };

    XmlspecRenderer.prototype.listitem = function(text) {
      if (/^\s*</.test(text)) {
        return "<item>" + text + "</item>";
      } else {
        return "<item><p>" + text + "</p></item>";
      }
    };

    XmlspecRenderer.prototype.paragraph = function(text) {
      return XmlspecRenderer.__super__.paragraph.call(this, text);
    };

    XmlspecRenderer.prototype.html = function(html) {
      return XmlspecRenderer.__super__.html.call(this, html);
    };

    XmlspecRenderer.prototype.blockquote = function(quote) {
      return "<quote>" + quote + "</quote>";
    };

    XmlspecRenderer.prototype.strong = function(text) {
      return "<rfc2119>" + text + "</rfc2119>";
    };

    XmlspecRenderer.prototype.em = function(text) {
      return "<emph>" + text + "</emph>";
    };

    XmlspecRenderer.prototype.link = function(href, title, text) {
      return "<loc href=\"" + href + "\">" + text + "</loc>";
    };

    return XmlspecRenderer;

  })(marked.Renderer);

  module.exports = XmlspecRenderer;

}).call(this);

//# sourceMappingURL=XmlspecRenderer.js.map
